# SideQuestCommunity — 大作业报告

> 项目定位：基于 SideQuestCommunity 项目的社交社区（Social Media Platform）案例研究。

---

## 1. 项目概述与目标 🎯

**目标**：设计并实现一个用于社区交流的 Web 应用，支持用户注册/登录、发帖、评论、点赞、收藏、关注、媒体上传、内容审核与搜索，演示完整的数据库设计与复杂 SQL 查询能力。

**主要模块**：身份认证（identity）、核心业务（core：帖子、评论）、媒体服务（media）、搜索服务（search）、审核服务（moderation）、分析服务（analytics）、API 网关（gateway）。

---

## 2. 需求分析（Requirement Analysis）✅

### 功能性需求（重点）
- 用户管理：注册、登录（JWT）、获取/更新个人资料、角色与权限管理。
- 帖子/互动：创建/编辑/删除帖子、评论与回复、点赞、收藏、标签、按作者/标签/时间筛选。
- 媒体管理：图片/视频上传、关联到帖子、媒体元数据管理。
- 社交关系：关注/取关、通知（评论/点赞/关注/系统通知）。
- 内容审核：敏感词过滤、举报与人工复审工作流。
- 搜索：全文检索（Elasticsearch）、按标签/关键词/作者搜索。

### 非功能性需求
- 安全：密码加密（bcrypt），JWT 鉴权，接口权限控制。
- 性能：热点缓存（Redis）、索引优化、分页策略。
- 可扩展性：微服务架构，使用消息队列（Kafka）做异步处理与数据同步。

---

## 3. 逻辑数据模型（LDM）🔗

**实体（示例 ≥ 10）：**
- `users`, `user_profiles`, `roles`, `user_roles`, `posts`, `comments`, `tags`, `post_tags`, `likes`, `bookmarks`, `follows`, `media`, `reports`, `notifications`

**关键关系示例**：
- `users` 1:1 `user_profiles`
- `users` 1:N `posts`
- `posts` N:M `tags` （经 `post_tags`）
- `users` N:M `roles` （经 `user_roles`）
- `comments` 支持自关联（parent_comment_id）
- `follows` 为用户的自关联表（follower -> followee）

> 提示：可使用 PowerDesigner / ERwin / PlantUML 绘制 ER 图（如需，我可生成 SVG/PNG）。

---

## 4. 物理数据模型（PDM）与优化建议 🔧

- 使用 InnoDB 引擎与字符集 `utf8mb4`。
- 主键采用 `BIGINT AUTO_INCREMENT`；短表使用 `INT`。
- 索引建议：`posts(user_id, created_at)`, `comments(post_id)`, `likes(post_id)`, `tags(name)`(UNIQUE)，`post_tags(post_id, tag_id)` 复合主键。
- 对热点统计（如点赞数）使用缓存或异步统计表，避免写放大。
- 数据库分区与读写分离在高并发场景中考虑使用。

---

## 5. MySQL 脚本（示例，完整脚本建议保存为 `sql/sidequest_schema.sql`）📄

```sql
CREATE DATABASE IF NOT EXISTS sidequest_db CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
USE sidequest_db;

CREATE TABLE users (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

CREATE TABLE user_profiles (
  user_id BIGINT PRIMARY KEY,
  display_name VARCHAR(100),
  bio TEXT,
  avatar_url VARCHAR(255),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- 省略其余表：roles, user_roles, posts, comments, tags, post_tags, likes, bookmarks, follows, media, reports, notifications
```

---

## 6. 功能实现映射（功能点与对应服务）🔗

- **用户管理**：`/api/identity/register`、`/api/identity/login`、密码重置、角色管理。
- **帖子 CRUD**：`/api/core/posts`（可实现 Create/Read/Update/Delete，权限控制：作者或管理员）。
- **评论/互动**：`/api/core/comments`, `/api/core/likes`, `/api/core/bookmarks`。
- **媒体上传**：`/api/media`（支持 OSS 直传与回调）。
- **审核与通知**：`/api/moderation`, `/api/notifications`。

---

## 7. SQL 示例（覆盖题目要求的查询类型）🧾

- **单表查询（Single-table）**
```sql
SELECT id, username, email FROM users WHERE email LIKE '%@example.com';
```

- **Join（内连接/外连接/自连接）**
```sql
-- 内连接：帖子与作者
SELECT p.id, p.title, u.username
FROM posts p JOIN users u ON p.user_id = u.id;

-- 左外连接：帖子及评论数
SELECT p.id, p.title, COALESCE(c.cnt,0) AS comment_count
FROM posts p
LEFT JOIN (SELECT post_id, COUNT(*) AS cnt FROM comments GROUP BY post_id) c ON p.id = c.post_id;

-- 自连接：关注者与被关注者
SELECT u1.username AS follower, u2.username AS followee
FROM follows f JOIN users u1 ON f.follower_id = u1.id JOIN users u2 ON f.followee_id = u2.id;
```

- **聚合 + GROUP BY + ORDER BY**
```sql
SELECT user_id, COUNT(*) AS posts FROM posts GROUP BY user_id ORDER BY posts DESC;
```

- **日期/时间函数**
```sql
SELECT * FROM posts WHERE created_at > DATE_SUB(NOW(), INTERVAL 30 DAY);
```

- **子查询**
```sql
SELECT * FROM posts WHERE user_id IN (SELECT id FROM users WHERE created_at > '2025-01-01');
```

- **相关子查询**
```sql
SELECT u.id, u.username, (SELECT COUNT(*) FROM posts p WHERE p.user_id = u.id) AS post_count FROM users u;
```

- **集合运算（UNION / INTERSECT / EXCEPT）**
```sql
SELECT id, username AS label, 'user' AS type FROM users WHERE username LIKE '%test%'
UNION
SELECT id, title AS label, 'post' AS type FROM posts WHERE title LIKE '%test%';
```

- **多表联接示例**
```sql
SELECT p.id, p.title, u.username, COUNT(c.id) AS comment_count
FROM posts p JOIN users u ON p.user_id = u.id LEFT JOIN comments c ON c.post_id = p.id
GROUP BY p.id, u.username HAVING comment_count > 5;
```

- **除法查询（示例）**
```sql
-- 查找点赞了标签 'Announcement' 的所有帖子中全部帖子都被该用户点赞的用户
SELECT l.user_id
FROM likes l
JOIN posts p ON l.post_id = p.id
JOIN post_tags pt ON pt.post_id = p.id
JOIN tags t ON t.id = pt.tag_id
WHERE t.name = 'Announcement'
GROUP BY l.user_id
HAVING COUNT(DISTINCT l.post_id) = (
  SELECT COUNT(DISTINCT p2.id) FROM posts p2 JOIN post_tags pt2 ON p2.id = pt2.post_id JOIN tags t2 ON pt2.tag_id = t2.id WHERE t2.name = 'Announcement'
);
```

---

## 8. UI/UX 与展示建议 🎨

- 关键页面截图：登录/注册、帖子列表/详情、发帖页、搜索页、管理员审核页。请将截图放入 `doc/screenshots/` 以便插入报告。
- 建议：为演示准备一个小规模样本数据并记录关键 SQL 执行结果截图。

---

## 9. 部署与运行 🚀

- 本 repo 已提供 `infra/docker-compose/`（含 Postgres/Redis/Kafka/ES/Nacos 等），可本地启动后运行微服务。
- 注意：作业要求为 MySQL，若需要可把 Spring Boot 的 `application.yml` 切换至 MySQL，并执行上文的建表脚本。

---

## 10. 最终提交材料清单（建议）📋
- `doc/大作业报告.md`（本文件）
- `doc/er_diagram.svg` 或 `doc/er_diagram.png`（ER 图）
- `sql/sidequest_schema.sql`（完整建表与索引脚本）
- `doc/screenshots/`（功能与 SQL 运行截图）
- 演示 PPT（包含关键页面与 SQL 执行结果）

---

## 11. 后续步骤（请回复选择）
1. 将完整 SQL 脚本保存为 `sql/sidequest_schema.sql`（我可以生成并添加）。
2. 生成 ER 图 PNG（`doc/er_diagram.png`）并把图片嵌入到本报告中（我可以导出并修改）。
3. 把示例数据插入脚本与更多示例查询加入 `sql/` 目录。
4. 其它（请说明）。

---

**已完成**：报告草稿已保存为 `doc/大作业报告.md`。

如果你确认，现在选择下一步（1/2/3/4），我会继续执行。